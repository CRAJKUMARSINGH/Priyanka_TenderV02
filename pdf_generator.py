import os
import subprocess
import logging
import tempfile
from typing import Dict, Any, Optional
import shutil
import re

logger = logging.getLogger(__name__)

class PDFGenerator:
    """Enhanced PDF generator using LaTeX compilation"""
    
    def __init__(self):
        self.output_dir = "outputs"
        self.temp_dir = "temp"
        self.ensure_directories()
    
    def ensure_directories(self):
        """Ensure required directories exist"""
        for directory in [self.output_dir, self.temp_dir]:
            os.makedirs(directory, exist_ok=True)
    
    def check_latex_installation(self) -> Dict[str, Any]:
        """Check if LaTeX is properly installed"""
        # Try Tectonic first (modern LaTeX engine)
        try:
            result = subprocess.run(
                ['tectonic', '--version'], 
                capture_output=True, 
                text=True, 
                timeout=10
            )
            
            if result.returncode == 0:
                return {
                    'installed': True,
                    'version': result.stdout.split('\n')[0] if result.stdout else 'Tectonic LaTeX Engine',
                    'command': 'tectonic'
                }
        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass
        
        # Fallback to pdflatex
        try:
            result = subprocess.run(
                ['pdflatex', '--version'], 
                capture_output=True, 
                text=True, 
                timeout=10
            )
            
            if result.returncode == 0:
                return {
                    'installed': True,
                    'version': result.stdout.split('\n')[0] if result.stdout else 'Unknown',
                    'command': 'pdflatex'
                }
        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass
                
        return {
            'installed': False,
            'error': 'No LaTeX engine found. Please install Tectonic or TeX Live.',
            'command': None,
            'install_hint': 'Install Tectonic or TeX Live for PDF generation'
        }
    
    def generate_pdf(self, latex_content: str, filename_base: str) -> Dict[str, Any]:
        """Generate PDF from LaTeX content"""
        try:
            # Check LaTeX installation first
            latex_check = self.check_latex_installation()
            if not latex_check['installed']:
                return {
                    'success': False,
                    'error': f"LaTeX not available: {latex_check.get('error', 'Unknown error')}",
                    'latex_check': latex_check
                }
            
            # Create temporary directory for compilation
            with tempfile.TemporaryDirectory(dir=self.temp_dir) as temp_compile_dir:
                tex_filename = f"{filename_base}.tex"
                pdf_filename = f"{filename_base}.pdf"
                
                tex_path = os.path.join(temp_compile_dir, tex_filename)
                pdf_temp_path = os.path.join(temp_compile_dir, pdf_filename)
                pdf_final_path = os.path.join(self.output_dir, pdf_filename)
                
                # Write LaTeX content to file
                try:
                    with open(tex_path, 'w', encoding='utf-8') as f:
                        f.write(latex_content)
                except Exception as e:
                    return {
                        'success': False,
                        'error': f"Failed to write LaTeX file: {str(e)}"
                    }
                
                # Compile PDF using available LaTeX engine
                compile_result = self._compile_latex(tex_path, temp_compile_dir, latex_check['command'])
                
                if not compile_result['success']:
                    return compile_result
                
                # Move PDF to output directory
                if os.path.exists(pdf_temp_path):
                    try:
                        shutil.move(pdf_temp_path, pdf_final_path)
                        logger.info(f"PDF generated successfully: {pdf_final_path}")
                        
                        return {
                            'success': True,
                            'pdf_path': pdf_final_path,
                            'filename': pdf_filename,
                            'size': os.path.getsize(pdf_final_path)
                        }
                    except Exception as e:
                        return {
                            'success': False,
                            'error': f"Failed to move PDF to output directory: {str(e)}"
                        }
                else:
                    return {
                        'success': False,
                        'error': "PDF file was not generated by LaTeX compilation"
                    }
                    
        except Exception as e:
            logger.error(f"Error generating PDF: {str(e)}")
            return {
                'success': False,
                'error': f"PDF generation failed: {str(e)}"
            }
    
    def _compile_latex(self, tex_path: str, work_dir: str, latex_command: str = 'pdflatex') -> Dict[str, Any]:
        """Compile LaTeX file to PDF using specified engine"""
        try:
            if latex_command == 'tectonic':
                # Tectonic compilation (single pass, modern engine)
                result1 = subprocess.run([
                    'tectonic',
                    '--outdir', work_dir,
                    tex_path
                ], 
                capture_output=True, 
                text=True, 
                cwd=work_dir,
                timeout=60
                )
            else:
                # pdflatex compilation (traditional)
                result1 = subprocess.run([
                    'pdflatex',
                    '-interaction=nonstopmode',
                    '-output-directory', work_dir,
                    tex_path
                ], 
                capture_output=True, 
                text=True, 
                cwd=work_dir,
                timeout=60
                )
            
            # Check if first compilation succeeded
            pdf_path = os.path.join(work_dir, os.path.basename(tex_path).replace('.tex', '.pdf'))
            
            if result1.returncode != 0:
                # Try to extract useful error information
                error_info = self._extract_latex_errors(result1.stdout, result1.stderr)
                return {
                    'success': False,
                    'error': f"LaTeX compilation failed: {error_info}",
                    'stdout': result1.stdout,
                    'stderr': result1.stderr,
                    'returncode': result1.returncode
                }
            
            # Second compilation for cross-references (only needed for pdflatex)
            if latex_command == 'pdflatex' and os.path.exists(pdf_path):
                try:
                    subprocess.run([
                        'pdflatex',
                        '-interaction=nonstopmode',
                        '-output-directory', work_dir,
                        tex_path
                    ], 
                    capture_output=True, 
                    text=True, 
                    cwd=work_dir,
                    timeout=60
                    )
                except subprocess.TimeoutExpired:
                    logger.warning("Second LaTeX compilation timed out, but PDF exists")
                except Exception as e:
                    logger.warning(f"Second LaTeX compilation failed: {str(e)}, but PDF exists")
            
            if os.path.exists(pdf_path):
                return {
                    'success': True,
                    'pdf_path': pdf_path,
                    'stdout': result1.stdout
                }
            else:
                return {
                    'success': False,
                    'error': "PDF file not created despite successful compilation",
                    'stdout': result1.stdout,
                    'stderr': result1.stderr
                }
                
        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'error': "LaTeX compilation timed out (60 seconds). Document may be too complex."
            }
        except FileNotFoundError:
            return {
                'success': False,
                'error': f"{latex_command} command not found. Please ensure LaTeX is installed."
            }
        except Exception as e:
            return {
                'success': False,
                'error': f"LaTeX compilation error: {str(e)}"
            }
    
    def _extract_latex_errors(self, stdout: str, stderr: str) -> str:
        """Extract meaningful error information from LaTeX output"""
        try:
            error_lines = []
            
            # Common LaTeX error patterns
            error_patterns = [
                r'! (.+)',  # LaTeX errors start with !
                r'.*Error.*',  # Lines containing "Error"
                r'.*undefined.*',  # Undefined command/reference errors
                r'.*not found.*',  # File not found errors
                r'.*missing.*',  # Missing character/font errors
            ]
            
            # Check stdout for errors
            for line in stdout.split('\n'):
                for pattern in error_patterns:
                    if re.search(pattern, line, re.IGNORECASE):
                        error_lines.append(line.strip())
                        break
            
            # Check stderr
            if stderr:
                error_lines.extend([line.strip() for line in stderr.split('\n') if line.strip()])
            
            if error_lines:
                # Return first few error lines
                return '; '.join(error_lines[:3])
            else:
                return "Unknown LaTeX compilation error"
                
        except Exception as e:
            return f"Error parsing LaTeX output: {str(e)}"
    
    def cleanup_temp_files(self, keep_tex: bool = False):
        """Clean up temporary compilation files"""
        try:
            if os.path.exists(self.temp_dir):
                for filename in os.listdir(self.temp_dir):
                    if not keep_tex and filename.endswith('.tex'):
                        continue
                    file_path = os.path.join(self.temp_dir, filename)
                    if os.path.isfile(file_path):
                        try:
                            os.remove(file_path)
                        except Exception as e:
                            logger.warning(f"Could not remove temp file {filename}: {str(e)}")
            
            logger.info("Temporary files cleaned up")
            
        except Exception as e:
            logger.warning(f"Error cleaning up temp files: {str(e)}")
    
    def get_latex_packages_status(self) -> Dict[str, bool]:
        """Check status of commonly required LaTeX packages"""
        packages = [
            'geometry',
            'fancyhdr', 
            'booktabs',
            'longtable',
            'array',
            'inputenc',
            'fontenc'
        ]
        
        package_status = {}
        
        for package in packages:
            try:
                # Create minimal test document
                test_doc = f"""\\documentclass{{article}}
\\usepackage{{{package}}}
\\begin{{document}}
Test
\\end{{document}}"""
                
                # Try to compile it
                with tempfile.TemporaryDirectory() as temp_dir:
                    test_file = os.path.join(temp_dir, 'test.tex')
                    
                    with open(test_file, 'w') as f:
                        f.write(test_doc)
                    
                    result = subprocess.run([
                        'pdflatex',
                        '-interaction=nonstopmode',
                        '-output-directory', temp_dir,
                        test_file
                    ], 
                    capture_output=True, 
                    timeout=10
                    )
                    
                    package_status[package] = (result.returncode == 0)
                    
            except Exception:
                package_status[package] = False
        
        return package_status
    
    def generate_latex_log_summary(self, log_content: str) -> Dict[str, Any]:
        """Generate summary of LaTeX compilation log"""
        try:
            summary = {
                'pages': 0,
                'warnings': 0,
                'errors': 0,
                'missing_packages': [],
                'overfull_hboxes': 0,
                'underfull_hboxes': 0
            }
            
            lines = log_content.split('\n')
            
            for line in lines:
                # Count pages
                if 'Output written on' in line and 'pages' in line:
                    try:
                        pages_match = re.search(r'(\d+) pages?', line)
                        if pages_match:
                            summary['pages'] = int(pages_match.group(1))
                    except:
                        pass
                
                # Count warnings and errors
                if line.startswith('LaTeX Warning'):
                    summary['warnings'] += 1
                
                if line.startswith('!') or 'Error:' in line:
                    summary['errors'] += 1
                
                # Check for missing packages
                if 'File `' in line and '.sty\' not found' in line:
                    try:
                        package_match = re.search(r'File `(.+?)\.sty\' not found', line)
                        if package_match:
                            summary['missing_packages'].append(package_match.group(1))
                    except:
                        pass
                
                # Count box warnings
                if 'Overfull \\hbox' in line:
                    summary['overfull_hboxes'] += 1
                
                if 'Underfull \\hbox' in line:
                    summary['underfull_hboxes'] += 1
            
            return summary
            
        except Exception as e:
            logger.error(f"Error generating LaTeX log summary: {str(e)}")
            return {'error': str(e)}
